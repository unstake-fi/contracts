{
  "contract_name": "unstake-reserve",
  "contract_version": "0.1.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "base_denom",
      "ghost_vault_addr",
      "owner"
    ],
    "properties": {
      "base_denom": {
        "description": "The base denom of the Reserve - ie the underlying bonded token",
        "type": "string"
      },
      "ghost_vault_addr": {
        "description": "The address of the associated GHOST vault",
        "allOf": [
          {
            "$ref": "#/definitions/Addr"
          }
        ]
      },
      "owner": {
        "$ref": "#/definitions/Addr"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Add funds to the Reserve.",
        "type": "object",
        "required": [
          "fund"
        ],
        "properties": {
          "fund": {
            "type": "object",
            "properties": {
              "callback": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CallbackData"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraw deposited reserve funds.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "properties": {
              "callback": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CallbackData"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Send reserves to a controller requesting them.",
        "type": "object",
        "required": [
          "request_reserves"
        ],
        "properties": {
          "request_reserves": {
            "type": "object",
            "required": [
              "requested_amount"
            ],
            "properties": {
              "callback": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CallbackData"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "requested_amount": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Accept returned reserves from a controller. Updates Reserve rates, decreasing rates if reserves are not fully returned, or increasing rates if reserves are returned alongside fees.",
        "type": "object",
        "required": [
          "return_reserves"
        ],
        "properties": {
          "return_reserves": {
            "type": "object",
            "required": [
              "original_amount"
            ],
            "properties": {
              "callback": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/CallbackData"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "original_amount": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Add the specified controller to the whitelist.",
        "type": "object",
        "required": [
          "add_controller"
        ],
        "properties": {
          "add_controller": {
            "type": "object",
            "required": [
              "controller"
            ],
            "properties": {
              "controller": {
                "$ref": "#/definitions/Addr"
              },
              "limit": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove the specified controller from the whitelist.",
        "type": "object",
        "required": [
          "remove_controller"
        ],
        "properties": {
          "remove_controller": {
            "type": "object",
            "required": [
              "controller"
            ],
            "properties": {
              "controller": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Update the Reserve config",
        "type": "object",
        "required": [
          "update_config"
        ],
        "properties": {
          "update_config": {
            "type": "object",
            "properties": {
              "owner": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Addr"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Migration Utility for legacy controller denoms",
        "type": "object",
        "required": [
          "migrate_legacy_reserve"
        ],
        "properties": {
          "migrate_legacy_reserve": {
            "type": "object",
            "required": [
              "legacy_denom",
              "legacy_redemption_rate",
              "reserves_deployed"
            ],
            "properties": {
              "legacy_denom": {
                "type": "string"
              },
              "legacy_redemption_rate": {
                "$ref": "#/definitions/Decimal"
              },
              "reserves_deployed": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Exchange a legacy reserve token for the new reserve token",
        "type": "object",
        "required": [
          "exchange_legacy_reserve"
        ],
        "properties": {
          "exchange_legacy_reserve": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "CallbackData": {
        "$ref": "#/definitions/Binary"
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "status"
        ],
        "properties": {
          "status": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "whitelist"
        ],
        "properties": {
          "whitelist": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ]
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ConfigResponse",
      "type": "object",
      "required": [
        "base_denom",
        "ghost_denom",
        "ghost_vault_addr",
        "owner",
        "rsv_denom"
      ],
      "properties": {
        "base_denom": {
          "type": "string"
        },
        "ghost_denom": {
          "type": "string"
        },
        "ghost_vault_addr": {
          "$ref": "#/definitions/Addr"
        },
        "owner": {
          "$ref": "#/definitions/Addr"
        },
        "rsv_denom": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "status": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StatusResponse",
      "type": "object",
      "required": [
        "available",
        "deployed",
        "reserve_redemption_rate",
        "total"
      ],
      "properties": {
        "available": {
          "description": "The amount of the reserve that is currently available. Denominated in ghost rcpt tokens.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "deployed": {
          "description": "The amount of the reserve that is currently allocated. Denominated in the base token.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "reserve_redemption_rate": {
          "description": "The redemption ratio of rsv tokens to ghost rcpt tokens",
          "allOf": [
            {
              "$ref": "#/definitions/Decimal"
            }
          ]
        },
        "total": {
          "description": "The total amount deposited in the reserve, denominated in the base token.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "whitelist": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "WhitelistResponse",
      "type": "object",
      "required": [
        "controllers"
      ],
      "properties": {
        "controllers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/WhitelistItem"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "WhitelistItem": {
          "type": "object",
          "required": [
            "controller",
            "lent"
          ],
          "properties": {
            "controller": {
              "$ref": "#/definitions/Addr"
            },
            "lent": {
              "$ref": "#/definitions/Uint128"
            },
            "limit": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Uint128"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        }
      }
    }
  }
}
